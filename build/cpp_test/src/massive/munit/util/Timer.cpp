// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_cpp_vm_Thread
#include <cpp/vm/Thread.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_massive_munit_util_Timer
#include <massive/munit/util/Timer.h>
#endif

namespace massive{
namespace munit{
namespace util{

void Timer_obj::__construct(Int time_ms){
            		HX_BEGIN_LOCAL_FUNC_S2(hx::LocalFunc,_hx_Closure_0, ::massive::munit::util::Timer,me,Int,time_ms) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("massive.munit.util.Timer","new",0xa904eb52,"massive.munit.util.Timer.new","massive/munit/util/Timer.hx",95,0xdb7ac55d)
HXLINE(  95)			me->runLoop(time_ms);
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_STACK_FRAME("massive.munit.util.Timer","new",0xa904eb52,"massive.munit.util.Timer.new","massive/munit/util/Timer.hx",77,0xdb7ac55d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(time_ms,"time_ms")
HXLINE(  94)		HX_VARI(  ::massive::munit::util::Timer,me) = hx::ObjectPtr<OBJ_>(this);
HXLINE(  95)		this->runThread = ::cpp::vm::Thread_obj::create( ::Dynamic(new _hx_Closure_0(me,time_ms)));
            	}

Dynamic Timer_obj::__CreateEmpty() { return new Timer_obj; }

hx::ObjectPtr< Timer_obj > Timer_obj::__new(Int time_ms)
{
	hx::ObjectPtr< Timer_obj > _hx_result = new Timer_obj();
	_hx_result->__construct(time_ms);
	return _hx_result;
}

Dynamic Timer_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Timer_obj > _hx_result = new Timer_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

void Timer_obj::stop(){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("massive.munit.util.Timer","stop",0x3ea268d0,"massive.munit.util.Timer.stop","massive/munit/util/Timer.hx",121,0xdb7ac55d)
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_STACK_FRAME("massive.munit.util.Timer","stop",0x3ea268d0,"massive.munit.util.Timer.stop","massive/munit/util/Timer.hx",100,0xdb7ac55d)
            	HX_STACK_THIS(this)
HXLINE( 121)		this->run =  ::Dynamic(new _hx_Closure_0());
HXLINE( 122)		this->runThread->sendMessage(HX_("stop",02,f0,5b,4c));
HXLINE( 124)		this->id = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Timer_obj,stop,(void))

HX_BEGIN_DEFAULT_FUNC(__default_run,Timer_obj)
void _hx_run(){
            	HX_STACK_FRAME("massive.munit.util.Timer","__default_run",0xa79737df,"massive.munit.util.Timer.__default_run","massive/munit/util/Timer.hx",128,0xdb7ac55d)
            	HX_STACK_THIS(this)
            	}
HX_END_LOCAL_FUNC0((void))
HX_END_DEFAULT_FUNC

void Timer_obj::runLoop(Int time_ms){
            	HX_STACK_FRAME("massive.munit.util.Timer","runLoop",0xec333741,"massive.munit.util.Timer.runLoop","massive/munit/util/Timer.hx",132,0xdb7ac55d)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(time_ms,"time_ms")
HXLINE( 133)		HX_VARI( Bool,shouldStop) = false;
HXLINE( 134)		while(!(shouldStop)){
HXLINE( 136)			::Sys_obj::sleep(((Float)time_ms / (Float)(int)1000));
HXLINE( 137)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 139)				this->run();
            			}
            			catch( ::Dynamic _hx_e){
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic ex = _hx_e;
HXLINE( 143)					::haxe::Log_obj::trace(ex,hx::SourceInfo(HX_("Timer.hx",39,a8,b7,da),143,HX_("massive.munit.util.Timer",60,9a,7c,a0),HX_("runLoop",4f,bb,f4,d4)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
HXLINE( 146)			HX_VARI( ::String,msg) = ( (::String)(::cpp::vm::Thread_obj::readMessage(false)) );
HXLINE( 147)			if ((msg == HX_("stop",02,f0,5b,4c))) {
HXLINE( 147)				shouldStop = true;
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Timer_obj,runLoop,(void))

 ::massive::munit::util::Timer Timer_obj::delay( ::Dynamic f,Int time_ms){
            		HX_BEGIN_LOCAL_FUNC_S2(hx::LocalFunc,_hx_Closure_0, ::Dynamic,f, ::massive::munit::util::Timer,t) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("massive.munit.util.Timer","delay",0xe28a12f5,"massive.munit.util.Timer.delay","massive/munit/util/Timer.hx",156,0xdb7ac55d)
HXLINE( 157)			t->stop();
HXLINE( 158)			f();
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_STACK_FRAME("massive.munit.util.Timer","delay",0xe28a12f5,"massive.munit.util.Timer.delay","massive/munit/util/Timer.hx",153,0xdb7ac55d)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(time_ms,"time_ms")
HXLINE( 154)		HX_VARI(  ::massive::munit::util::Timer,t) =  ::massive::munit::util::Timer_obj::__new(time_ms);
HXLINE( 155)		t->run =  ::Dynamic(new _hx_Closure_0(f,t));
HXLINE( 160)		return t;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Timer_obj,delay,return )

Float Timer_obj::stamp(){
            	HX_STACK_FRAME("massive.munit.util.Timer","stamp",0x8f6eab75,"massive.munit.util.Timer.stamp","massive/munit/util/Timer.hx",172,0xdb7ac55d)
HXLINE( 172)		return ::Sys_obj::time();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Timer_obj,stamp,return )


Timer_obj::Timer_obj()
{
	run = new __default_run(this);
}

void Timer_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Timer);
	HX_MARK_MEMBER_NAME(id,"id");
	HX_MARK_MEMBER_NAME(runThread,"runThread");
	HX_MARK_MEMBER_NAME(run,"run");
	HX_MARK_END_CLASS();
}

void Timer_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(id,"id");
	HX_VISIT_MEMBER_NAME(runThread,"runThread");
	HX_VISIT_MEMBER_NAME(run,"run");
}

hx::Val Timer_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { return hx::Val( id); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"run") ) { return hx::Val( run); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"stop") ) { return hx::Val( stop_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"runLoop") ) { return hx::Val( runLoop_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"runThread") ) { return hx::Val( runThread); }
	}
	return super::__Field(inName,inCallProp);
}

bool Timer_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"delay") ) { outValue = delay_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"stamp") ) { outValue = stamp_dyn(); return true; }
	}
	return false;
}

hx::Val Timer_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { id=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"run") ) { run=inValue.Cast<  ::Dynamic >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"runThread") ) { runThread=inValue.Cast<  ::cpp::vm::Thread >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Timer_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("id","\xdb","\x5b","\x00","\x00"));
	outFields->push(HX_HCSTRING("runThread","\x75","\xe0","\x15","\xb5"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Timer_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Timer_obj,id),HX_HCSTRING("id","\xdb","\x5b","\x00","\x00")},
	{hx::fsObject /*::cpp::vm::Thread*/ ,(int)offsetof(Timer_obj,runThread),HX_HCSTRING("runThread","\x75","\xe0","\x15","\xb5")},
	{hx::fsObject /*Dynamic*/ ,(int)offsetof(Timer_obj,run),HX_HCSTRING("run","\x4b","\xe7","\x56","\x00")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Timer_obj_sStaticStorageInfo = 0;
#endif

static ::String Timer_obj_sMemberFields[] = {
	HX_HCSTRING("id","\xdb","\x5b","\x00","\x00"),
	HX_HCSTRING("runThread","\x75","\xe0","\x15","\xb5"),
	HX_HCSTRING("stop","\x02","\xf0","\x5b","\x4c"),
	HX_HCSTRING("run","\x4b","\xe7","\x56","\x00"),
	HX_HCSTRING("runLoop","\x4f","\xbb","\xf4","\xd4"),
	::String(null()) };

static void Timer_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Timer_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Timer_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Timer_obj::__mClass,"__mClass");
};

#endif

hx::Class Timer_obj::__mClass;

static ::String Timer_obj_sStaticFields[] = {
	HX_HCSTRING("delay","\x83","\xd7","\x26","\xd7"),
	HX_HCSTRING("stamp","\x03","\x70","\x0b","\x84"),
	::String(null())
};

void Timer_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("massive.munit.util.Timer","\x60","\x9a","\x7c","\xa0");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Timer_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Timer_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Timer_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Timer_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Timer_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Timer_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Timer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Timer_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace massive
} // end namespace munit
} // end namespace util
