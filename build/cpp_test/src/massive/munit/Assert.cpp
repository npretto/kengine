// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_ValueType
#include <ValueType.h>
#endif
#ifndef INCLUDED_massive_haxe_Exception
#include <massive/haxe/Exception.h>
#endif
#ifndef INCLUDED_massive_munit_Assert
#include <massive/munit/Assert.h>
#endif
#ifndef INCLUDED_massive_munit_AssertionException
#include <massive/munit/AssertionException.h>
#endif
#ifndef INCLUDED_massive_munit_MUnitException
#include <massive/munit/MUnitException.h>
#endif

namespace massive{
namespace munit{

void Assert_obj::__construct() { }

Dynamic Assert_obj::__CreateEmpty() { return new Assert_obj; }

hx::ObjectPtr< Assert_obj > Assert_obj::__new()
{
	hx::ObjectPtr< Assert_obj > _hx_result = new Assert_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Assert_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Assert_obj > _hx_result = new Assert_obj();
	_hx_result->__construct();
	return _hx_result;
}

Int Assert_obj::assertionCount;

void Assert_obj::isTrue(Bool value, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","isTrue",0x34cf1719,"massive.munit.Assert.isTrue","massive/munit/Assert.hx",52,0xdba0f24f)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(info,"info")
HXLINE(  53)		::massive::munit::Assert_obj::assertionCount++;
HXLINE(  54)		if ((value != true)) {
HXLINE(  54)			::String _hx_tmp = ::Std_obj::string(value);
HXDLIN(  54)			::massive::munit::Assert_obj::fail(((HX_("Expected TRUE but was [",bb,60,fc,33) + _hx_tmp) + HX_("]",5d,00,00,00)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,isTrue,(void))

void Assert_obj::isFalse(Bool value, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","isFalse",0xe5859778,"massive.munit.Assert.isFalse","massive/munit/Assert.hx",64,0xdba0f24f)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(info,"info")
HXLINE(  65)		::massive::munit::Assert_obj::assertionCount++;
HXLINE(  66)		if ((value != false)) {
HXLINE(  66)			::String _hx_tmp = ::Std_obj::string(value);
HXDLIN(  66)			::massive::munit::Assert_obj::fail(((HX_("Expected FALSE but was [",20,19,a9,73) + _hx_tmp) + HX_("]",5d,00,00,00)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,isFalse,(void))

void Assert_obj::isNull( ::Dynamic value, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","isNull",0x30da0e52,"massive.munit.Assert.isNull","massive/munit/Assert.hx",76,0xdba0f24f)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(info,"info")
HXLINE(  77)		::massive::munit::Assert_obj::assertionCount++;
HXLINE(  78)		Bool _hx_tmp = hx::IsNotNull( value );
HXDLIN(  78)		if (_hx_tmp) {
HXLINE(  78)			::String _hx_tmp1 = ::Std_obj::string(value);
HXDLIN(  78)			::massive::munit::Assert_obj::fail(((HX_("Value [",cc,41,bd,3d) + _hx_tmp1) + HX_("] was not NULL",2e,e4,6d,32)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,isNull,(void))

void Assert_obj::isNotNull( ::Dynamic value, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","isNotNull",0xec2b6a4f,"massive.munit.Assert.isNotNull","massive/munit/Assert.hx",88,0xdba0f24f)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(info,"info")
HXLINE(  89)		::massive::munit::Assert_obj::assertionCount++;
HXLINE(  90)		Bool _hx_tmp = hx::IsNull( value );
HXDLIN(  90)		if (_hx_tmp) {
HXLINE(  90)			::String _hx_tmp1 = ::Std_obj::string(value);
HXDLIN(  90)			::massive::munit::Assert_obj::fail(((HX_("Value [",cc,41,bd,3d) + _hx_tmp1) + HX_("] was NULL",01,2d,fc,2c)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,isNotNull,(void))

void Assert_obj::isNaN(Float value, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","isNaN",0x97c09f50,"massive.munit.Assert.isNaN","massive/munit/Assert.hx",100,0xdba0f24f)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(info,"info")
HXLINE( 101)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 102)		Bool _hx_tmp = !(::Math_obj::isNaN(value));
HXDLIN( 102)		if (_hx_tmp) {
HXLINE( 102)			::massive::munit::Assert_obj::fail(((HX_("Value [",cc,41,bd,3d) + value) + HX_("]  was not NaN",9a,1a,04,75)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,isNaN,(void))

void Assert_obj::isNotNaN(Float value, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","isNotNaN",0x370391f3,"massive.munit.Assert.isNotNaN","massive/munit/Assert.hx",112,0xdba0f24f)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(info,"info")
HXLINE( 113)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 114)		Bool _hx_tmp = ::Math_obj::isNaN(value);
HXDLIN( 114)		if (_hx_tmp) {
HXLINE( 114)			::massive::munit::Assert_obj::fail(((HX_("Value [",cc,41,bd,3d) + value) + HX_("] was NaN",61,ab,90,31)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,isNotNaN,(void))

void Assert_obj::isType( ::Dynamic value, ::Dynamic type, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","isType",0x34d46285,"massive.munit.Assert.isType","massive/munit/Assert.hx",124,0xdba0f24f)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(type,"type")
            	HX_STACK_ARG(info,"info")
HXLINE( 125)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 126)		Bool _hx_tmp = !(::Std_obj::is(value,type));
HXDLIN( 126)		if (_hx_tmp) {
HXLINE( 126)			::String _hx_tmp1 = ::Std_obj::string(value);
HXDLIN( 126)			::massive::munit::Assert_obj::fail((((HX_("Value [",cc,41,bd,3d) + _hx_tmp1) + HX_("] was not of type: ",c2,44,01,71)) + ::Type_obj::getClassName(type)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,isType,(void))

void Assert_obj::isNotType( ::Dynamic value, ::Dynamic type, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","isNotType",0xf025be82,"massive.munit.Assert.isNotType","massive/munit/Assert.hx",136,0xdba0f24f)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(type,"type")
            	HX_STACK_ARG(info,"info")
HXLINE( 137)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 138)		Bool _hx_tmp = ::Std_obj::is(value,type);
HXDLIN( 138)		if (_hx_tmp) {
HXLINE( 138)			::String _hx_tmp1 = ::Std_obj::string(value);
HXDLIN( 138)			::massive::munit::Assert_obj::fail((((HX_("Value [",cc,41,bd,3d) + _hx_tmp1) + HX_("] was of type: ",0f,1f,fb,82)) + ::Type_obj::getClassName(type)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,isNotType,(void))

void Assert_obj::areEqual( ::Dynamic expected, ::Dynamic actual, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","areEqual",0x455d6dc1,"massive.munit.Assert.areEqual","massive/munit/Assert.hx",152,0xdba0f24f)
            	HX_STACK_ARG(expected,"expected")
            	HX_STACK_ARG(actual,"actual")
            	HX_STACK_ARG(info,"info")
HXLINE( 153)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 154)		HX_VAR( Bool,equal);
HXDLIN( 154)		HX_VARI( ::hx::EnumBase,_g) = ::Type_obj::_hx_typeof(expected);
HXDLIN( 154)		Int _hx_tmp = ( ( ::hx::EnumBase)(_g) )->_hx_getIndex();
HXDLIN( 154)		if ((_hx_tmp == (int)7)) {
HXLINE( 154)			equal = ::Type_obj::enumEq(expected,actual);
            		}
            		else {
HXLINE( 154)			equal = hx::IsEq( expected,actual );
            		}
HXLINE( 164)		if (!(equal)) {
HXLINE( 164)			::String _hx_tmp1 = ::Std_obj::string(actual);
HXDLIN( 164)			::String _hx_tmp2 = ((HX_("Value [",cc,41,bd,3d) + _hx_tmp1) + HX_("] was not equal to expected value [",16,a1,2f,2d));
HXDLIN( 164)			::String _hx_tmp3 = ::Std_obj::string(expected);
HXDLIN( 164)			::massive::munit::Assert_obj::fail(((_hx_tmp2 + _hx_tmp3) + HX_("]",5d,00,00,00)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,areEqual,(void))

void Assert_obj::areNotEqual( ::Dynamic expected, ::Dynamic actual, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","areNotEqual",0x6c4589b4,"massive.munit.Assert.areNotEqual","massive/munit/Assert.hx",178,0xdba0f24f)
            	HX_STACK_ARG(expected,"expected")
            	HX_STACK_ARG(actual,"actual")
            	HX_STACK_ARG(info,"info")
HXLINE( 179)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 180)		HX_VAR( Bool,equal);
HXDLIN( 180)		HX_VARI( ::hx::EnumBase,_g) = ::Type_obj::_hx_typeof(expected);
HXDLIN( 180)		Int _hx_tmp = ( ( ::hx::EnumBase)(_g) )->_hx_getIndex();
HXDLIN( 180)		if ((_hx_tmp == (int)7)) {
HXLINE( 180)			equal = ::Type_obj::enumEq(expected,actual);
            		}
            		else {
HXLINE( 180)			equal = hx::IsEq( expected,actual );
            		}
HXLINE( 190)		if (equal) {
HXLINE( 190)			::String _hx_tmp1 = ::Std_obj::string(actual);
HXDLIN( 190)			::String _hx_tmp2 = ((HX_("Value [",cc,41,bd,3d) + _hx_tmp1) + HX_("] was equal to value [",ad,d8,e6,f1));
HXDLIN( 190)			::String _hx_tmp3 = ::Std_obj::string(expected);
HXDLIN( 190)			::massive::munit::Assert_obj::fail(((_hx_tmp2 + _hx_tmp3) + HX_("]",5d,00,00,00)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,areNotEqual,(void))

void Assert_obj::areSame( ::Dynamic expected, ::Dynamic actual, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","areSame",0x02a125f9,"massive.munit.Assert.areSame","massive/munit/Assert.hx",201,0xdba0f24f)
            	HX_STACK_ARG(expected,"expected")
            	HX_STACK_ARG(actual,"actual")
            	HX_STACK_ARG(info,"info")
HXLINE( 202)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 203)		if (hx::IsNotEq( expected,actual )) {
HXLINE( 203)			::String _hx_tmp = ::Std_obj::string(actual);
HXDLIN( 203)			::String _hx_tmp1 = ((HX_("Value [",cc,41,bd,3d) + _hx_tmp) + HX_("] was not the same as expected value [",ae,5f,06,10));
HXDLIN( 203)			::String _hx_tmp2 = ::Std_obj::string(expected);
HXDLIN( 203)			::massive::munit::Assert_obj::fail(((_hx_tmp1 + _hx_tmp2) + HX_("]",5d,00,00,00)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,areSame,(void))

void Assert_obj::areNotSame( ::Dynamic expected, ::Dynamic actual, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","areNotSame",0x76c00966,"massive.munit.Assert.areNotSame","massive/munit/Assert.hx",214,0xdba0f24f)
            	HX_STACK_ARG(expected,"expected")
            	HX_STACK_ARG(actual,"actual")
            	HX_STACK_ARG(info,"info")
HXLINE( 215)		::massive::munit::Assert_obj::assertionCount++;
HXLINE( 216)		if (hx::IsEq( expected,actual )) {
HXLINE( 216)			::String _hx_tmp = ::Std_obj::string(actual);
HXDLIN( 216)			::String _hx_tmp1 = ((HX_("Value [",cc,41,bd,3d) + _hx_tmp) + HX_("] was the same as expected value [",81,49,22,3e));
HXDLIN( 216)			::String _hx_tmp2 = ::Std_obj::string(expected);
HXDLIN( 216)			::massive::munit::Assert_obj::fail(((_hx_tmp1 + _hx_tmp2) + HX_("]",5d,00,00,00)),info);
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Assert_obj,areNotSame,(void))

void Assert_obj::fail(::String msg, ::Dynamic info){
            	HX_STACK_FRAME("massive.munit.Assert","fail",0x65f6825f,"massive.munit.Assert.fail","massive/munit/Assert.hx",227,0xdba0f24f)
            	HX_STACK_ARG(msg,"msg")
            	HX_STACK_ARG(info,"info")
HXLINE( 227)		HX_STACK_DO_THROW( ::massive::munit::AssertionException_obj::__new(msg,info));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Assert_obj,fail,(void))


Assert_obj::Assert_obj()
{
}

bool Assert_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"fail") ) { outValue = fail_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"isNaN") ) { outValue = isNaN_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"isTrue") ) { outValue = isTrue_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isNull") ) { outValue = isNull_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isType") ) { outValue = isType_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"isFalse") ) { outValue = isFalse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"areSame") ) { outValue = areSame_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"isNotNaN") ) { outValue = isNotNaN_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"areEqual") ) { outValue = areEqual_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isNotNull") ) { outValue = isNotNull_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"isNotType") ) { outValue = isNotType_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"areNotSame") ) { outValue = areNotSame_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"areNotEqual") ) { outValue = areNotEqual_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"assertionCount") ) { outValue = assertionCount; return true; }
	}
	return false;
}

bool Assert_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 14:
		if (HX_FIELD_EQ(inName,"assertionCount") ) { assertionCount=ioValue.Cast< Int >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Assert_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Assert_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Assert_obj::assertionCount,HX_HCSTRING("assertionCount","\xad","\x2e","\xc2","\x06")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Assert_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Assert_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Assert_obj::assertionCount,"assertionCount");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Assert_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Assert_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Assert_obj::assertionCount,"assertionCount");
};

#endif

hx::Class Assert_obj::__mClass;

static ::String Assert_obj_sStaticFields[] = {
	HX_HCSTRING("assertionCount","\xad","\x2e","\xc2","\x06"),
	HX_HCSTRING("isTrue","\x58","\x6c","\x6a","\x6a"),
	HX_HCSTRING("isFalse","\x59","\xd9","\xd4","\x97"),
	HX_HCSTRING("isNull","\x91","\x63","\x75","\x66"),
	HX_HCSTRING("isNotNull","\x70","\xa6","\x37","\x42"),
	HX_HCSTRING("isNaN","\xf1","\xf6","\x51","\xc1"),
	HX_HCSTRING("isNotNaN","\xf2","\xf4","\x0d","\x8a"),
	HX_HCSTRING("isType","\xc4","\xb7","\x6f","\x6a"),
	HX_HCSTRING("isNotType","\xa3","\xfa","\x31","\x46"),
	HX_HCSTRING("areEqual","\xc0","\xd0","\x67","\x98"),
	HX_HCSTRING("areNotEqual","\x15","\xd0","\xf1","\x8a"),
	HX_HCSTRING("areSame","\xda","\x67","\xf0","\xb4"),
	HX_HCSTRING("areNotSame","\x25","\x6a","\x68","\x6b"),
	HX_HCSTRING("fail","\xde","\xb9","\xb5","\x43"),
	::String(null())
};

void Assert_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("massive.munit.Assert","\x8d","\x67","\x6a","\x3c");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Assert_obj::__GetStatic;
	__mClass->mSetStaticField = &Assert_obj::__SetStatic;
	__mClass->mMarkFunc = Assert_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Assert_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Assert_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Assert_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Assert_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Assert_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Assert_obj::__boot()
{
{
            	HX_STACK_FRAME("massive.munit.Assert","boot",0x635c4cb3,"massive.munit.Assert.boot","massive/munit/Assert.hx",43,0xdba0f24f)
HXLINE(  43)		assertionCount = (int)0;
            	}
}

} // end namespace massive
} // end namespace munit
